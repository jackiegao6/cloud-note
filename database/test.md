## 1.Mysql性能慢的原因

- sql语句未优化
- 索引未命中
- 数据表设计的太大



## 排查sql语句查询慢的方法

- 慢查询日志
- explain 具体的sql语句 分析执行计划



## 什么是三大范式，为什么要有三大范式，什么场景下不用遵循三大范式，举一个场景

- 1NF：要求字段不可再分
- 2NF：要求表中的每一列都和主键直接相关
- 3NF：要求表中除了主键列之外的其他列 不能有依赖关系
- 便于维护、减少冗余、保持一致性
- 当需要减少表连接次数时 可以把其他表的适当字段冗余到当前表中 从而提高查询效率
- 比如订单表中除了 订单ID 用户ID 商品ID之外，把商品价格 冗余进来

## 说说 SQL 的语法树解析？

- 是 **数据库执行 SQL 语句前的重要步骤**，它属于 **SQL 执行的第一阶段 —— 解析阶段（Parsing）**，用于将 SQL 文本语句变成数据库能理解的“结构化对象”
- 是把 SQL 语句变成机器可以理解的结构表示，是后续优化和执行的基础

## mysql分为几层？binlog写入在哪一层

- 连接层：连接池 权限管理
- 服务层：binlog写入 SQL解析-优化-执行
- 存储引擎层：读写操作 提供不同的存储方式 事务支持

## MySQL中一条SQL的执行流程

####  1. **客户端连接**

- 客户端通过 TCP 协议连接 MySQL 服务器
- MySQL 进行：
  - 连接管理（线程/连接池）
  - 身份验证（账号/密码）
  - 权限校验（是否有执行该 SQL 的权限）

#### 2. **SQL 解析阶段**

- SQL 字符串经过词法、语法分析，生成**抽象语法树（AST）**
- 然后进行**语义分析**
  - 表、字段是否存在
  - 数据类型是否匹配
- 生成逻辑执行结构（不是物理执行计划）

#### 3. **优化阶段（查询优化器）**

- 优化器根据语法树生成 **多个执行计划**
- 然后选择一个**代价最低（最优）的执行计划**
  - 是否使用索引？哪个索引？
  - 表连接顺序（Join Order）？
  - 是否可以改写为更优的形式？

工具：`EXPLAIN` 可以查看优化后的执行计划

####  4. **执行阶段（执行器）**

- 执行器根据执行计划逐步调用存储引擎的 API
- 例如：
  - 执行 `SELECT` 时，请求存储引擎读取数据页
  - 执行 `UPDATE` 时，先读取，再修改，再写入日志

####  5. **访问存储引擎**

- MySQL 会通过接口访问具体的存储引擎（默认是 InnoDB）
- 存储引擎完成实际的磁盘读写
  - 查询数据页 → 缓存中找不到 → 从磁盘加载
  - 插入、更新 → 写入 redo log + 数据页

####  6. **返回结果到客户端**

- 将结果从存储引擎返回给 Server 层
- Server 层进行排序、分组、聚合等二次处理（如果 SQL 需要）
- 将最终结果通过网络协议返回给客户端

#### 特殊情况：有 binlog 和事务时

- 对于 **数据变更语句**（INSERT/UPDATE/DELETE）：
  - 先写 **binlog**（Server 层）
  - 再写 **redo log**（InnoDB 层）
  - 最后通过 **两阶段提交（2PC）** 确保 binlog 和 redo log 一致

##  一条更新语句是如何执行的？

